knitr::opts_chunk$set(echo = TRUE)
## Load Packages
library(tidyverse)
library(plater)
file.names <- dir("./plater-templates/")
file.paths<- paste0("./plater-templates/", file.names)
plates <- read_plates(file.paths)
colnames(plates)
head(plates)
colnames(plates) <- c("plate", "wells", "id", "fluor", "bad_wells", "ph_batch")
head(plates)
file.names <- dir("./plater-templates/")
file.paths<- paste0("./plater-templates/", file.names)
plates <- read_plates(file.paths)
colnames(plates) <- c("plate", "wells", "id", "fluor", "bad_wells", "ph_batch")
head(plates)
unique(plates$plate) # To check that all plates read in correctly
#Remove empty wells
nrow(plates)
plates <- subset(plates, !is.na(id) & id != 0 & ID != ".")
plates <- subset(plates, !is.na(id) & id != 0 & id != ".")
nrow(plates)
# Remove bad wells and keep good ones
plates <- subset(plates, bad_wells != "bad" & bad_wells != "Bad"
& bad_wells != "x" & bad_wells != "X" | is.na(Bad_wells))
# Remove bad wells and keep good ones
plates <- subset(plates, bad_wells != "bad" & bad_wells != "Bad"
& bad_wells != "x" & bad_wells != "X" | is.na(bad_wells))
nrow(plates)
knitr::opts_chunk$set(echo = TRUE)
## Load Packages
library(tidyverse)
library(plater)
library(glue)
file.names <- dir("./plater-templates/")
file.paths<- paste0("./plater-templates/", file.names)
plates <- read_plates(file.paths)
colnames(plates) <- c("plate", "wells", "id", "fluor", "bad_wells", "ph_batch")
head(plates)
unique(plates$plate) # To check that all plates read in correctly
nrow(plates)
#Remove empty wells
nrow(plates)
no_missing <- subset(plates, !is.na(id) & id != 0 & id != ".")
nrow(plates)
# Remove bad wells and keep good ones
no_bad <- subset(no_missing, bad_wells != "bad" & bad_wells != "Bad"
& bad_wells != "x" & bad_wells != "X" | is.na(bad_wells))
nrow(no_bad)
wells_removed <- nrow(plates) - nrow(no_bad)
glue("Removed {wells_removed} wells that were missing or bad")
knitr::opts_chunk$set(echo = TRUE)
## Load Packages
library(tidyverse)
library(plater)
library(glue)
knitr::opts_chunk$set(echo = TRUE)
## Load Packages
library(tidyverse)
library(plater)
library(glue)
file.names <- dir("./plater-templates/")
file.paths<- paste0("./plater-templates/", file.names)
plates <- read_plates(file.paths)
colnames(plates) <- c("plate", "wells", "id", "fluor", "bad_wells", "ph_batch")
head(plates)
unique(plates$plate) # To check that all plates read in correctly
nrow(plates)
#Remove empty wells
no_missing <- subset(plates, !is.na(id) & id != 0 & id != ".")
# Remove bad wells and keep good ones
no_bad <- subset(no_missing, bad_wells != "bad" & bad_wells != "Bad"
& bad_wells != "x" & bad_wells != "X" & is.na(bad_wells))
wells_removed <- nrow(plates) - nrow(no_bad)
glue("Removed {wells_removed} wells that were missing or bad")
#Remove empty wells
no_missing <- subset(plates, !is.na(id) & id != 0 & id != ".")
# Remove bad wells and keep good ones
no_bad <- subset(no_missing, bad_wells != "bad" & bad_wells != "Bad"
& bad_wells != "x" & bad_wells != "X" | is.na(bad_wells))
wells_removed <- nrow(plates) - nrow(no_bad)
glue("Removed {wells_removed} wells that were missing or bad")
#Remove empty wells
no_missing <- subset(plates, !is.na(id) & id != 0 & id != ".")
# Remove bad wells and keep good ones
no_bad <- subset(no_missing, is.na(bad_wells))
wells_removed <- nrow(plates) - nrow(no_bad)
glue("Removed {wells_removed} wells that were missing or bad")
clean_data <- wells_removed
colnames(clean_data)
knitr::opts_chunk$set(echo = TRUE)
## Load Packages
library(tidyverse)
library(plater)
library(glue)
clean_data <- no_bad
colnames(clean_data)
head(clean_data)
str_detect(clean_data$wells, "12")
#Obtain the plate blank value by averaging the values in column 12 of each plate
colnames(clean_data)
knitr::opts_chunk$set(echo = TRUE)
## Load Packages
library(tidyverse)
library(plater)
library(glue)
file.names <- dir("./plater-templates/")
file.paths<- paste0("./plater-templates/", file.names)
plates <- read_plates(file.paths)
colnames(plates) <- c("plate", "wells", "id", "fluor", "bad_wells", "ph_batch")
head(plates)
unique(plates$plate) # To check that all plates read in correctly
nrow(plates)
#Remove empty wells
no_missing <- subset(plates, !is.na(id) & id != 0 & id != ".")
# Remove bad wells and keep good ones
no_bad <- subset(no_missing, is.na(bad_wells))
#original PMN script has the code below to remove bad wells. Based on the way I have been filling out my templates, I think it can be sipmlified to subsetting based on "is.na(bad_wells)"
# plates <- subset(plates, Bad_wells != "bad" & Bad_wells != "Bad"
#                  & Bad_wells != "x" & Bad_wells != "X" | is.na(Bad_wells))
wells_removed <- nrow(plates) - nrow(no_bad)
glue("Removed {wells_removed} wells that were missing or bad")
clean_data <- no_bad
clean_data %>%
select(plate, wells, id, ph_batch) %>%
filter(wells, str_detect("12"))
clean_data %>%
select(plate, wells, id, ph_batch) %>%
filter(wells, str_detect(clean_data$wells, "12"))
plate_blanks <- str_detect(clean_data$wells, "12")
clean_data %>%
select(plate, wells, id, ph_batch) %>%
filter(id == "Buf")
#Obtain the plate blank value by averaging the values in column 12 of each plate
colnames(clean_data)
clean_data %>%
select(plate, wells, id, fluor, ph_batch) %>%
filter(id == "Buf") %>%
group_by(plate) %>%
summarise(mean = mean(fluor), n = n())
plate_blanks <- clean_data %>%
select(plate, wells, id, fluor, ph_batch) %>%
filter(id == "Buf") %>%
group_by(plate) %>%
summarise(mean = mean(fluor), n = n())
plate_blanks <- clean_data %>%
select(plate, wells, id, fluor, ph_batch) %>%
filter(id == "Buf") %>%
group_by(plate) %>%
summarise(mean = mean(fluor), n = n())
# Average the MUB standard values for each MUB concentration
mub_stds <- clean_data %>%
select(plate, wells, id, fluor, ph_batch) %>%
filter(str_detect(wells, "10"))
mub_stds
mub_stds <- clean_data %>%
select(plate, wells, id, fluor, ph_batch) %>%
filter(str_detect(wells, "10")) %>%
group_by(plate, id) %>%
summarise(mub_std_mean = mean(fluor), n = n())
mub_stds
plate_blanks
plate_blanks <- clean_data %>%
select(plate, wells, id, fluor, ph_batch) %>%
filter(id == "Buf") %>%
group_by(plate) %>%
summarise(plate_blnk_mean = mean(fluor), n = n())
mub_stds
plate_blanks
plate_blanks <- clean_data %>%
select(plate, wells, id, fluor, ph_batch) %>%
filter(id == "Buf") %>%
group_by(plate) %>%
summarise(plate_blnk_mean = mean(fluor), n = n())
# Average the MUB standard values (column 10) for each MUB concentration
mub_stds <- clean_data %>%
select(plate, wells, id, fluor, ph_batch) %>%
filter(str_detect(wells, "10")) %>%
group_by(plate, id) %>%
summarise(mub_std_mean = mean(fluor), n = n())
left_join(plate_blanks, mub_stds, by = "plate")
ext_coeff_tbl <- left_join(plate_blanks, mub_stds, by = "plate")
ext_coeff_tbl
ext_coeff_tbl %>%
select(-n.x, -n.y)
ext_coeff_tbl %>%
select(-n.x, -n.y) %>%
mutate(corrected_mub_std_mean = mub_std_mean - plate_blnk_mean)
ext_coeff_tbl %>%
select(-n.x, -n.y) %>%
mutate(corrected_mub_std_mean = mub_std_mean - plate_blnk_mean, mub_conc = as.numeric(str_replace(ext_coeff_tbl$id, "MUB", "")))
#Obtain the plate blank value by averaging the values in column 12 (id = Buf) of each plate
plate_blanks <- clean_data %>%
select(plate, wells, id, fluor, ph_batch) %>%
filter(id == "Buf") %>%
group_by(plate) %>%
summarise(plate_blnk_mean = mean(fluor), n = n())
# Average the MUB standard values (column 10) for each MUB concentration
mub_stds <- clean_data %>%
select(plate, wells, id, fluor, ph_batch) %>%
filter(str_detect(wells, "10")) %>%
group_by(plate, id) %>%
summarise(mub_std_mean = mean(fluor), n = n())
#Create a column for the plate blank values by joining the plate_blanks and mub_stds tbls
join_std_blnk <- left_join(plate_blanks, mub_stds, by = "plate")
#Subtract the plate blank from the fluorescence values for each averaged concentration
ext_coeff_tbl <- join_std_blnk %>%
select(-n.x, -n.y) %>%
mutate(corr_mub_std_mean = mub_std_mean - plate_blnk_mean, mub_conc_uM = as.numeric(str_replace(ext_coeff_tbl$id, "MUB", "")))
# Function to get equation and R-sq for a model
lm_eqn <- function(m) {
l <- list(intcpt = format(abs(coef(m)[1]), digits = 3, scientific=FALSE),
slope = format(coef(m)[2], digits = 3, scientific=FALSE),
rsq = format(summary(m)["r.squared"], digits = 3));
if (coef(m)[1] >= 0)  {
eq <- paste("y = ", l["slope"], "x + ", l["intcpt"], ", R^2 = ", l["rsq"], sep = "")
} else {
eq <- paste("y = ", l["slope"], "x - ", l["intcpt"], ", R^2 = ", l["rsq"], sep = "")
}
}
# Function to plot a standard curve with equation and R-sq
plot.curve <- function(data, model) {
plot(abs ~ conc, data, main = unique(data$Plate)) +
abline(model) +
mtext(lm_eqn(model), side = 3)
}
# Set up matrix to record coefficients and max conc for each plate's standard curve
coeff <- matrix(data = NA, ncol = 4, nrow = length(stds.list))
stds.list <- split(ext_coeff_tbl, ext_coeff_tbl$plate)
# Function to get equation and R-sq for a model
lm_eqn <- function(m) {
l <- list(intcpt = format(abs(coef(m)[1]), digits = 3, scientific=FALSE),
slope = format(coef(m)[2], digits = 3, scientific=FALSE),
rsq = format(summary(m)["r.squared"], digits = 3));
if (coef(m)[1] >= 0)  {
eq <- paste("y = ", l["slope"], "x + ", l["intcpt"], ", R^2 = ", l["rsq"], sep = "")
} else {
eq <- paste("y = ", l["slope"], "x - ", l["intcpt"], ", R^2 = ", l["rsq"], sep = "")
}
}
# Function to plot a standard curve with equation and R-sq
plot.curve <- function(data, model) {
plot(abs ~ conc, data, main = unique(data$Plate)) +
abline(model) +
mtext(lm_eqn(model), side = 3)
}
# Set up matrix to record coefficients and max conc for each plate's standard curve
coeff <- matrix(data = NA, ncol = 4, nrow = length(stds.list))
colnames(coeff)=c("plate", "intcpt", "slope", "max.abs")
# Set up a matrix to record notes for each plate
curve.notes <- matrix(data = NA, ncol = 2, nrow = length(stds.list))
colnames(curve.notes)=c("plate", "notes")
# Set the minimum number of standards for a curve
# The absolute minimum to plot a straight line is 3
# We normally use 5-6 standards
min_stds <- 4
stds_list <- split(ext_coeff_tbl, ext_coeff_tbl$plate)
# Function to get equation and R-sq for a model
lm_eqn <- function(m) {
l <- list(intcpt = format(abs(coef(m)[1]), digits = 3, scientific=FALSE),
slope = format(coef(m)[2], digits = 3, scientific=FALSE),
rsq = format(summary(m)["r.squared"], digits = 3));
if (coef(m)[1] >= 0)  {
eq <- paste("y = ", l["slope"], "x + ", l["intcpt"], ", R^2 = ", l["rsq"], sep = "")
} else {
eq <- paste("y = ", l["slope"], "x - ", l["intcpt"], ", R^2 = ", l["rsq"], sep = "")
}
}
# Function to plot a standard curve with equation and R-sq
plot.curve <- function(data, model) {
plot(abs ~ conc, data, main = unique(data$Plate)) +
abline(model) +
mtext(lm_eqn(model), side = 3)
}
# Set up matrix to record coefficients and max conc for each plate's standard curve
coeff <- matrix(data = NA, ncol = 4, nrow = length(stds_list))
colnames(coeff)=c("plate", "intcpt", "slope", "max.abs")
# Set up a matrix to record notes for each plate
curve.notes <- matrix(data = NA, ncol = 2, nrow = length(stds_list))
colnames(curve.notes)=c("plate", "notes")
# Set the minimum number of standards for a curve
# The absolute minimum to plot a straight line is 3
# We normally use 5-6 standards
min_stds <- 4
for(i in 1:length(stds_list)) {
# Check number of standards
if(length(stds_list[[i]]$ID) < min_stds) {
# Record the plate name
coeff[i, "plate"] <- names(stds_list)[i]
# Feedback
curve.notes[i, ] <- c(names(stds_list[i]), "Need to redo plate (not enough good standards)")
} else {
# Calculate curve
m1 <- lm(abs ~ conc, stds_list[[i]])
rsq1 <- summary(m1)["r.squared"]
# Plot the standard curve
plot.curve(stds_list[[i]], m1)
if (rsq1 >= 0.98) {
# Save the coefficients
coeff[i, "Plate"] <- names(stds_list)[i]
coeff[i, 2:3] <- coef(m1)
coeff[i, 4] <- max(stds_list[[i]]$abs)
# Feedback
curve.notes[i, ] <- c(names(stds_list[i]), "Standard curve looks good!")
} else {
# Record the plate name
coeff[i, "Plate"] <- names(stds_list)[i]
# Feedback
curve.notes[i, ] <- c(names(stds_list[i]), "Need to redo plate (bad standard curve)")
}
# Clean up
rm(m1)
rm(rsq1)
}
}
print(curve.notes)
for(i in 1:length(stds_list)) {
# Check number of standards
if(length(stds_list[[i]]$id) < min_stds) {
# Record the plate name
coeff[i, "plate"] <- names(stds_list)[i]
# Feedback
curve.notes[i, ] <- c(names(stds_list[i]), "Need to redo plate (not enough good standards)")
} else {
# Calculate curve
m1 <- lm(corr_mub_std_mean ~ mub_conc_uM, stds_list[[i]])
rsq1 <- summary(m1)["r.squared"]
# Plot the standard curve
plot.curve(stds_list[[i]], m1)
if (rsq1 >= 0.98) {
# Save the coefficients
coeff[i, "plate"] <- names(stds_list)[i]
coeff[i, 2:3] <- coef(m1)
coeff[i, 4] <- max(stds_list[[i]]$abs)
# Feedback
curve.notes[i, ] <- c(names(stds_list[i]), "Standard curve looks good!")
} else {
# Record the plate name
coeff[i, "plate"] <- names(stds_list)[i]
# Feedback
curve.notes[i, ] <- c(names(stds_list[i]), "Need to redo plate (bad standard curve)")
}
# Clean up
rm(m1)
rm(rsq1)
}
}
# Function to get equation and R-sq for a model
lm_eqn <- function(m) {
l <- list(intcpt = format(abs(coef(m)[1]), digits = 3, scientific=FALSE),
slope = format(coef(m)[2], digits = 3, scientific=FALSE),
rsq = format(summary(m)["r.squared"], digits = 3));
if (coef(m)[1] >= 0)  {
eq <- paste("y = ", l["slope"], "x + ", l["intcpt"], ", R^2 = ", l["rsq"], sep = "")
} else {
eq <- paste("y = ", l["slope"], "x - ", l["intcpt"], ", R^2 = ", l["rsq"], sep = "")
}
}
# Function to plot a standard curve with equation and R-sq
plot.curve <- function(data, model) {
plot(corr_mub_std_mean ~ mub_conc_uM, data, main = unique(data$plate)) +
abline(model) +
mtext(lm_eqn(model), side = 3)
}
# Set up matrix to record coefficients and max conc for each plate's standard curve
coeff <- matrix(data = NA, ncol = 4, nrow = length(stds_list))
colnames(coeff)=c("plate", "intcpt", "slope", "max.abs")
# Set up a matrix to record notes for each plate
curve.notes <- matrix(data = NA, ncol = 2, nrow = length(stds_list))
colnames(curve.notes)=c("plate", "notes")
# Set the minimum number of standards for a curve
# The absolute minimum to plot a straight line is 3
# We normally use 5-6 standards
min_stds <- 4
for(i in 1:length(stds_list)) {
# Check number of standards
if(length(stds_list[[i]]$id) < min_stds) {
# Record the plate name
coeff[i, "plate"] <- names(stds_list)[i]
# Feedback
curve.notes[i, ] <- c(names(stds_list[i]), "Need to redo plate (not enough good standards)")
} else {
# Calculate curve
m1 <- lm(corr_mub_std_mean ~ mub_conc_uM, stds_list[[i]])
rsq1 <- summary(m1)["r.squared"]
# Plot the standard curve
plot.curve(stds_list[[i]], m1)
if (rsq1 >= 0.98) {
# Save the coefficients
coeff[i, "plate"] <- names(stds_list)[i]
coeff[i, 2:3] <- coef(m1)
coeff[i, 4] <- max(stds_list[[i]]$abs)
# Feedback
curve.notes[i, ] <- c(names(stds_list[i]), "Standard curve looks good!")
} else {
# Record the plate name
coeff[i, "plate"] <- names(stds_list)[i]
# Feedback
curve.notes[i, ] <- c(names(stds_list[i]), "Need to redo plate (bad standard curve)")
}
# Clean up
rm(m1)
rm(rsq1)
}
}
print(curve.notes)
knitr::opts_chunk$set(echo = TRUE)
## Load Packages
library(tidyverse)
library(plater)
library(glue)
file.names <- dir("./plater-templates/")
file.paths<- paste0("./plater-templates/", file.names)
plates <- read_plates(file.paths)
colnames(plates) <- c("plate", "wells", "id", "fluor", "bad_wells", "ph_batch")
head(plates)
unique(plates$plate) # To check that all plates read in correctly
nrow(plates)
#Remove empty wells
no_missing <- subset(plates, !is.na(id) & id != 0 & id != ".")
# Remove bad wells and keep good ones
no_bad <- subset(no_missing, is.na(bad_wells))
#original PMN script has the code below to remove bad wells. Based on the way I have been filling out my templates, I think it can be sipmlified to subsetting based on "is.na(bad_wells)"
# plates <- subset(plates, Bad_wells != "bad" & Bad_wells != "Bad"
#                  & Bad_wells != "x" & Bad_wells != "X" | is.na(Bad_wells))
wells_removed <- nrow(plates) - nrow(no_bad)
glue("Removed {wells_removed} wells that were missing or bad")
clean_data <- no_bad
#Obtain the plate blank value by averaging the values in column 12 (id = Buf) of each plate
plate_blanks <- clean_data %>%
select(plate, wells, id, fluor, ph_batch) %>%
filter(id == "Buf") %>%
group_by(plate) %>%
summarise(plate_blnk_mean = mean(fluor), n = n())
# Average the MUB standard values (column 10) for each MUB concentration
mub_stds <- clean_data %>%
select(plate, wells, id, fluor, ph_batch) %>%
filter(str_detect(wells, "10")) %>%
group_by(plate, id) %>%
summarise(mub_std_mean = mean(fluor), n = n())
#Create a column for the plate blank values by joining the plate_blanks and mub_stds tbls
join_std_blnk <- left_join(plate_blanks, mub_stds, by = "plate")
#Subtract the plate blank from the fluorescence values for each averaged concentration
ext_coeff_tbl <- join_std_blnk %>%
select(-n.x, -n.y) %>%
mutate(corr_mub_std_mean = mub_std_mean - plate_blnk_mean, mub_conc_uM = as.numeric(str_replace(ext_coeff_tbl$id, "MUB", "")))
stds_list <- split(ext_coeff_tbl, ext_coeff_tbl$plate)
# Function to get equation and R-sq for a model
lm_eqn <- function(m) {
l <- list(intcpt = format(abs(coef(m)[1]), digits = 3, scientific=FALSE),
slope = format(coef(m)[2], digits = 3, scientific=FALSE),
rsq = format(summary(m)["r.squared"], digits = 3));
if (coef(m)[1] >= 0)  {
eq <- paste("y = ", l["slope"], "x + ", l["intcpt"], ", R^2 = ", l["rsq"], sep = "")
} else {
eq <- paste("y = ", l["slope"], "x - ", l["intcpt"], ", R^2 = ", l["rsq"], sep = "")
}
}
# Function to plot a standard curve with equation and R-sq
plot.curve <- function(data, model) {
plot(corr_mub_std_mean ~ mub_conc_uM, data, main = unique(data$plate)) +
abline(model) +
mtext(lm_eqn(model), side = 3)
}
# Set up matrix to record coefficients and max conc for each plate's standard curve
coeff <- matrix(data = NA, ncol = 4, nrow = length(stds_list))
colnames(coeff)=c("plate", "intcpt", "slope", "max.abs")
# Set up a matrix to record notes for each plate
curve.notes <- matrix(data = NA, ncol = 2, nrow = length(stds_list))
colnames(curve.notes)=c("plate", "notes")
# Set the minimum number of standards for a curve
# The absolute minimum to plot a straight line is 3
# We normally use 5-6 standards
min_stds <- 4
for(i in 1:length(stds_list)) {
# Check number of standards
if(length(stds_list[[i]]$id) < min_stds) {
# Record the plate name
coeff[i, "plate"] <- names(stds_list)[i]
# Feedback
curve.notes[i, ] <- c(names(stds_list[i]), "Need to redo plate (not enough good standards)")
} else {
# Calculate curve
m1 <- lm(corr_mub_std_mean ~ mub_conc_uM, stds_list[[i]])
rsq1 <- summary(m1)["r.squared"]
# Plot the standard curve
plot.curve(stds_list[[i]], m1)
if (rsq1 >= 0.98) {
# Save the coefficients
coeff[i, "plate"] <- names(stds_list)[i]
coeff[i, 2:3] <- coef(m1)
coeff[i, 4] <- max(stds_list[[i]]$corr_mub_std_mean)
# Feedback
curve.notes[i, ] <- c(names(stds_list[i]), "Standard curve looks good!")
} else {
# Record the plate name
coeff[i, "plate"] <- names(stds_list)[i]
# Feedback
curve.notes[i, ] <- c(names(stds_list[i]), "Need to redo plate (bad standard curve)")
}
# Clean up
rm(m1)
rm(rsq1)
}
}
print(curve.notes)
