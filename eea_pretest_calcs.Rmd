---
title: "Hydrolytic Extracellular Enzyme Pre-test Calculations"
author: "Hava Blair"
date: "June 18, 2020"
output: html_document
---
## Enzyme Pre-test Calculations 

```{r, packages, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

## Load Packages 
library(tidyverse)
library(plater)
library(glue)

```

# Need to change mentions of "extinction" to "emission" ???  
# Think about setting warnings for when # of standards is <4, and for when assay fluor exceeds max std fluor.

## Read in plate templates

You need one completed template file (find template HERE XXXXXXX) for each plate, in CSV format. 

Name your file with the ID of your plate.  This will be added as its own column by plater so that you can identify which plate the data is coming from. 

Files used with this version of the script should contain all the metadata in the csv file itself, in 4 blocks:

  --"template" = standard, blank, and sample IDs.  Empty wells (no sample, standard, or check) may be coded as ".", "0" (zero), "NA", or left blank.
  
  --"Data" = raw fluorescence data from the plate reader
  
  --"bad_wells" = identifies any wells that have known problems (ex. pipetting errors).  May be coded as "bad", "Bad", "x", or "X".  Anything with NA (blank) will be kept as "good"
  
  --"ph_batch" has the pH of the buffer you used for this plate
  
The files you want to process must all be in a single folder, and that folder must not contain any other files R will attempt to read in all files in the designated folder.

Now you are ready to read in your files. If you get an error, check whether you have any extra CSV files in the designated folder.

```{r files}
file.names <- dir("./plater-templates/")
file.paths<- paste0("./plater-templates/", file.names)
plates <- read_plates(file.paths)
colnames(plates) <- c("plate", "wells", "id", "fluor", "bad_wells", "ph_batch", "conc_uM")
head(plates)
unique(plates$plate) # To check that all plates read in correctly
colnames(plates)

```

## Remove empty wells and known bad wells


```{r, badwells}
#Remove empty wells
no_missing <- subset(plates, !is.na(id) & id != 0 & id != ".")

# Remove bad wells and keep good ones
no_bad <- subset(no_missing, is.na(bad_wells))

#Create a dataframe with the details about which wells were removed as "bad".  Can write this to CSV now, or wait until after later QC checks to compile a list of samples that need to be redone.
bad_list <- subset(no_missing, !is.na(bad_wells))

bad_list

#original PMN script from Miriam has the code below to remove bad wells. Based on the way I have been filling out my templates, I think it can be sipmlified to subsetting based on "is.na(bad_wells)"
# plates <- subset(plates, Bad_wells != "bad" & Bad_wells != "Bad" 
#                  & Bad_wells != "x" & Bad_wells != "X" | is.na(Bad_wells))

wells_removed <- nrow(plates) - nrow(no_bad)

glue("Removed {wells_removed} wells that were missing or bad")

clean_data <- no_bad

clean_nested <- clean_data %>% 
  group_by(plate) %>% 
  nest()

```

```{r}
get_plate_blank <- function(data){
  buf <- data %>% 
    filter(id == "Buf")
    mean(buf$fluor)
}

test <- clean_nested %>% 
  mutate(plate_blank = map_dbl(data, get_plate_blank))

test

```


## MUB Standard calculations

```{r}
mub_std_fun <- function(data){
  data %>%
    select(wells, id, fluor, ph_batch, conc_uM) %>% 
    filter(str_detect(wells, "10")) %>% 
    group_by(id) %>% 
    summarise(mub_std_mean = mean(fluor), n = n()) #Add CV here?
}

mub_std_test <- test %>% 
  mutate(mub_std_values = map(data, mub_std_fun))

#Can always include an "unnest" option here for quick viewing of the plate numbers and standards


#Subtract the plate blank from the fluorescence values for each averaged concentration

corr_test <- mub_std_test %>% 
  unnest(mub_std_values) %>% 
  mutate(corr_mub_std = mub_std_mean - plate_blank, mub_conc_uM = as.numeric(str_replace(id, "MUB", ""))) %>% 
  nest(std_data = c(plate_blank, id, mub_std_mean, n, corr_mub_std, mub_conc_uM))

corr_test

```
### MUB + Soil Standards (Quench)

```{r}
#Obtain the plate blank + soil fluorescence value by averaging the values in column 11 (id = Buf+s) of each plate

get_mub_soil_blank <- function(data){
  buf_soil <- data %>% 
    filter(id == "Buf+s")
    mean(buf_soil$fluor)
}

calc_mub_soil_blnk <- corr_test %>% 
  mutate(mub_soil_blank = map_dbl(data, get_mub_soil_blank))

calc_mub_soil_blnk

quench_std_fun <- function(data){
  data %>%
    select(wells, id, fluor, ph_batch, conc_uM) %>% 
    filter(str_detect(wells, "09")) %>% 
    mutate(conc_uM = as.numeric(str_replace(conc_uM, "mub_", ""))) %>% 
    group_by(conc_uM) %>% 
    summarise(mub_std_mean = mean(fluor), n = n()) #Add CV here?
}

quench_test <- calc_mub_soil_blnk %>% 
  mutate(quench_std_values = map(data, quench_std_fun))

quench_test

#Subtract the blank values from the fluorescence values for each averaged MUB concentration

## START HERE on Tuesday morning.  Unnest the quench_std_values as above and calculate corrected fluor for the standard curve. 

# quench_tbl <- join_soil_std_blnk %>% 
#   select(-n.x, -n.y) %>% 
#   mutate(corr_std_mean = mub_soil_std_mean - plate_blnk_soil_mean, mub_conc_uM = str_replace(join_soil_std_blnk$id, "MUB", ""))
# 
# mub_soil_stds$conc_uM <- str_replace(mub_soil_stds$conc_uM, "mub_", "")
# mub_soil_stds$conc_uM <- as.numeric(mub_conc_uM$mub_conc_uM)

quench_tbl <- mub_soil_stds
quench_tbl$mub_conc_uM <- as.numeric(str_replace(quench_tbl$mub_conc_uM, "mub_", ""))

quench_tbl
ext_coeff_tbl
```

## Put the data for the extinction & quench standard curves in nested table 

```{r}
colnames(clean_nested) <- c("plate", "all_data")

ext_nested <- ext_coeff_tbl %>% 
  group_by(plate) %>% 
  nest()

colnames(ext_nested) <- c("plate", "ext_data")

quench_nested <- quench_tbl %>% 
  group_by(plate) %>% 
  nest()

colnames(quench_nested) <- c("plate", "quench_data")


nest_groups <- merge(clean_nested, ext_nested, by = "plate")
nest_groups <- merge(nest_groups, quench_nested)

nest_groups
```


##Functions to operate on the nested dataframe 

```{r}
lm_mod_ftn <- function(df){
  lm(corr_std_mean ~ mub_conc_uM, data = df)
}

b_fun <- function(mod){
  coefficients(mod)[[1]]
}

slope_fun <- function(mod){
  coefficients(mod)[[2]]
}

r_sq_fun <- function(mod){
  summary(mod)[["r.squared"]]
}

max_fluor_fun <- function(data){
  max(data$corr_std_mean)
}

```


##Run linear models for standard curves (extinction & quench)

```{r}
lm_calcs <- nest_groups %>% 
  mutate(ext_lm = map(ext_data, lm_mod_ftn), quench_lm = map(quench_data, lm_mod_ftn))

lm_calcs

```

##Extract model details 

```{r}

ext_mod_details <- lm_calcs %>% 
  mutate(ext_intcpt = map_dbl(ext_lm, b_fun), ext_m_slope = map_dbl(ext_lm, slope_fun), ext_r_squared = map_dbl(ext_lm, r_sq_fun), ext_max_fluor = map_dbl(ext_data, max_fluor_fun))

ext_mod_details

mod_details <- ext_mod_details %>% 
  mutate(quench_intcpt = map_dbl(quench_lm, b_fun), quench_m_slope = map_dbl(quench_lm, slope_fun), quench_r_squared = map_dbl(quench_lm, r_sq_fun), quench_max_fluor = map_dbl(quench_data, max_fluor_fun))

mod_details

```

# Plot emission curves
```{r, emission-curves}
plate_list <- unique(mod_details$plate)
index <- c(1:4)


ext_curve_plot <- function(plate){
  
  plate_data <- mod_details %>% 
    unnest(ext_data) %>% 
    filter(plate == plate)
  plate_data %>% 
    ggplot(aes(x = mub_conc_uM, y = corr_std_mean)) + 
    geom_point() + 
    geom_abline(data = plate_data, aes(slope = ext_m_slope, intercept = ext_intcpt)) +
    geom_text(data = plate_data, aes(x = 1.5, y = 8000,
                          label = paste("R^2=", round(ext_r_squared, digits = 3))), inherit.aes = FALSE) + 
    geom_text(data = plate_data, aes(x = 1.0, y = 10000,
                                    label = paste(" y= ", round(ext_m_slope, digits = 2),
                                      "x", " + ", round(ext_intcpt, digits = 2))), inherit.aes = FALSE) +
    labs(title = glue("{plate} emission standard curve"))
  
}
  
quench_curve_plot <- function(plate, quench_data_df){
  quench_data_df %>% 
  ggplot(aes(x = mub_conc_uM, y = corr_std_mean)) + 
  geom_point() + 
  geom_abline(data = mod_details, aes(slope = quench_m_slope, intercept = quench_intcpt)) +
  geom_text(data = mod_details, aes(x = 1.5, y = 2000,
                          label = paste("R^2=", round(quench_r_squared, digits = 3))), inherit.aes = FALSE) + 
  geom_text(data = mod_details, aes(x = 1.0, y = 2500,
                                    label = paste(" y= ", round(quench_m_slope, digits = 2),
                                      "x", " + ", round(quench_intcpt, digits = 2))), inherit.aes = FALSE) + 
  labs(title = glue("{plate} quench standard curves"))
  
}



## Add the standard curves to the nested table 
add_std_curves <- mod_details %>% 
  mutate(ext_std_curves = pmap(mod_details$ext_data, index, plate_list, ext_curve_plot))
   
add_std_curves$ext_std_curves      
         # , 
         # quench_std_curves = map2(plate_list, mod_details$quench_data, quench_curve_plot))
         # 

ext_curve_plot("1B-ST2-7")

plate_1 <- mod_details %>% 
  unnest(ext_data) %>% 
  filter(plate == "1B-ST2-7") %>% 
  select(corr_std_mean, mub_conc_uM, ext_intcpt, ext_m_slope, ext_r_squared, ext_max_fluor)

ggplot(plate_1) +
  geom_point(aes(x = mub_conc_uM, y = corr_std_mean))

plate_1 <- as.data.frame(plate_1)

typeof(plate_1)


```


# Plot quench curves
```{r, quench-curves}

                                        

```




## Combine the emission and quench coefficient tables 


```{r}
quench_select <- quench_tbl %>% 
  select(plate, id, corr_std_mean, mub_conc_uM) %>% 
  mutate(id = "quench")

ext_select <- ext_coeff_tbl %>% 
  select(plate, id, corr_std_mean, mub_conc_uM) %>% 
  mutate(id = "emission")

stds_for_lm <- rbind(quench_select, ext_select)

stds_list_cols <- stds_for_lm %>% 
  group_by(plate, id) %>% 
  nest()

lm_mod_ftn <- function(df){
  lm(corr_std_mean ~ mub_conc_uM, data = df)
}

m_stds_list <- stds_list_cols %>% 
  mutate(model = map(data, lm_mod_ftn))

b_fun <- function(mod){
  coefficients(mod)[[1]]
}

slope_fun <- function(mod){
  coefficients(mod)[[2]]
}

r_sq_fun <- function(mod){
  summary(mod)[["r.squared"]]
}

max_fluor_fun <- function(data){
  max(data$corr_std_mean)
}

stds_coeffs <- m_stds_list %>% 
  transmute(intcpt = map_dbl(model, b_fun), m_slope = map_dbl(model, slope_fun), r_squared = map_dbl(model, r_sq_fun), max_fluor = map_dbl(data, max_fluor_fun))

stds_coeffs

```


### Calculate extinction coefficient

The emission coefficient is the slope (m) from the emission standard curves you made above, divided by the assay volume 

Pay attention to units! 
**slope (m) units** from the standard curves = fluor/uM = fluor/ (umol/L) = fluor L / umol = fluor mL / nmol

**assay volume** is 250uL = 0.00025 L = 0.250 mL 

The protocol states: "Make sure this is calculated with the MUB concentrations in nmol/mL, which is equivalent to umol/L."" 

```{r, extintion-coefficient}
assay_vol_ml <- 0.250

# emission coefficient units are fluorescence / nmol
calc_emission <-  emission_only %>% 
  mutate(ext_coeff_fluor_per_nmol = m_slope/assay_vol_ml) %>% 
  select(plate, max_fluor, ext_coeff_fluor_per_nmol, intcpt)

calc_emission
```


### Calculate the quench coefficient 
```{r, quench-coefficient}
quench_coeff <- stds_coeffs %>% 
  pivot_wider(id_cols = plate, names_from = id, names_prefix = "slope_", values_from = m_slope) %>% 
  mutate(quench_coeff_no_unit = slope_quench/slope_emission)

quench_coeff

all_calcs <- cbind(quench_coeff, calc_emission) %>% 
  select(-id, -plate1)

all_calcs
```



### Add extinction & quench data to sample dataset 

```{r}

clean_with_calcs <- left_join(clean_data, all_calcs, by = "plate")

clean_with_calcs

#can use an ifelse statement to restore the mub concentrations to the clean_data tbl? Maybe first do the mean calcs for each assay and substrate blank row, then restore the mub conentrations to the table

# nest by template and average by conc_uM

clean_with_calcs %>% 
  group_by(plate) %>% 
  nest()

```


```{r}

```

