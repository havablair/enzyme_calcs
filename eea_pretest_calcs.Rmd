---
title: "Hydrolytic Extracellular Enzyme Pre-test Calculations"
author: "Hava Blair"
date: "June 18, 2020"
output: html_document
---
## Enzyme Pre-test Calculations 

```{r, packages, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

## Load Packages 
library(tidyverse)
library(plater)
library(glue)

```

# Need to change mentions of "extinction" to "emission" ???  
# Think about setting warnings for when # of standards is <4, and for when assay fluor exceeds max std fluor.

## Read in plate templates

You need one completed template file (find template HERE XXXXXXX) for each plate, in CSV format. 

Name your file with the ID of your plate.  This will be added as its own column by plater so that you can identify which plate the data is coming from. 

Files used with this version of the script should contain all the metadata in the csv file itself, in 4 blocks:

  --"template" = standard, blank, and sample IDs.  Empty wells (no sample, standard, or check) may be coded as ".", "0" (zero), "NA", or left blank.
  
  --"Data" = raw fluorescence data from the plate reader
  
  --"bad_wells" = identifies any wells that have known problems (ex. pipetting errors).  May be coded as "bad", "Bad", "x", or "X".  Anything with NA (blank) will be kept as "good"
  
  --"ph_batch" has the pH of the buffer you used for this plate
  
The files you want to process must all be in a single folder, and that folder must not contain any other files R will attempt to read in all files in the designated folder.

Now you are ready to read in your files. If you get an error, check whether you have any extra CSV files in the designated folder.

```{r files}
file.names <- dir("./plater-templates/")
file.paths<- paste0("./plater-templates/", file.names)
plates <- read_plates(file.paths)
colnames(plates) <- c("plate", "wells", "id", "fluor", "bad_wells", "ph_batch")
head(plates)
unique(plates$plate) # To check that all plates read in correctly
nrow(plates)
```

## Remove empty wells and known bad wells


```{r, badwells}
#Remove empty wells
no_missing <- subset(plates, !is.na(id) & id != 0 & id != ".")

# Remove bad wells and keep good ones
no_bad <- subset(no_missing, is.na(bad_wells))

#original PMN script has the code below to remove bad wells. Based on the way I have been filling out my templates, I think it can be sipmlified to subsetting based on "is.na(bad_wells)"
# plates <- subset(plates, Bad_wells != "bad" & Bad_wells != "Bad" 
#                  & Bad_wells != "x" & Bad_wells != "X" | is.na(Bad_wells))

wells_removed <- nrow(plates) - nrow(no_bad)

glue("Removed {wells_removed} wells that were missing or bad")

clean_data <- no_bad
```

## Emission coefficient determination

```{r}
#Obtain the plate blank value by averaging the values in column 12 (id = Buf) of each plate

plate_blanks <- clean_data %>% 
  select(plate, wells, id, fluor, ph_batch) %>% 
  filter(id == "Buf") %>% 
  group_by(plate) %>% 
  summarise(plate_blnk_mean = mean(fluor), n = n())

# Average the MUB standard values (column 10) for each MUB concentration
mub_stds <- clean_data %>% 
  select(plate, wells, id, fluor, ph_batch) %>% 
  filter(str_detect(wells, "10")) %>% 
  group_by(plate, id) %>% 
  summarise(mub_std_mean = mean(fluor), n = n())

#Create a column for the plate blank values by joining the plate_blanks and mub_stds tbls
join_std_blnk <- left_join(plate_blanks, mub_stds, by = "plate")

#Subtract the plate blank from the fluorescence values for each averaged concentration
ext_coeff_tbl <- join_std_blnk %>% 
  select(-n.x, -n.y) %>% 
  mutate(corr_std_mean = mub_std_mean - plate_blnk_mean, mub_conc_uM = as.numeric(str_replace(join_std_blnk$id, "MUB", "")))

ext_coeff_tbl

```
### Quench controls

```{r}
 #Obtain the plate blank + soil fluorescence value by averaging the values in column 11 (id = Buf+s) of each plate

plate_blnk_soil <- clean_data %>% 
  select(plate, wells, id, fluor, ph_batch) %>% 
  filter(id == "Buf+s") %>% 
  group_by(plate) %>% 
  summarise(plate_blnk_soil_mean = mean(fluor), n = n())

# Average the MUB+soil fluorescence values (column 9) for each MUB concentration
mub_soil_stds <- clean_data %>% 
  select(plate, wells, id, fluor, ph_batch) %>% 
  filter(str_detect(wells, "09")) %>% 
  group_by(plate, id) %>% 
  summarise(mub_soil_std_mean = mean(fluor), n = n())

#Create a column for the plate blank values by joining the plate_blanks and mub_stds tbls
join_soil_std_blnk <- left_join(plate_blnk_soil, mub_soil_stds, by = "plate")

join_soil_std_blnk

#Subtract the blank values from the fluorescence values for each averaged MUB concentration
quench_tbl <- join_soil_std_blnk %>% 
  select(-n.x, -n.y) %>% 
  mutate(corr_std_mean = mub_soil_std_mean - plate_blnk_soil_mean, mub_conc_uM = str_replace(join_soil_std_blnk$id, "MUB", ""))

quench_tbl$mub_conc_uM <- str_replace(quench_tbl$mub_conc_uM, "\\+", "")
quench_tbl$mub_conc_uM <- as.numeric(str_replace(quench_tbl$mub_conc_uM, "S", ""))

```

## Combine the emission and quench coefficient tables 


```{r}
quench_select <- quench_tbl %>% 
  select(plate, id, corr_std_mean, mub_conc_uM) %>% 
  mutate(id = "quench")

ext_select <- ext_coeff_tbl %>% 
  select(plate, id, corr_std_mean, mub_conc_uM) %>% 
  mutate(id = "emission")

stds_for_lm <- rbind(quench_select, ext_select)

stds_list_cols <- stds_for_lm %>% 
  group_by(plate, id) %>% 
  nest()

lm_mod_ftn <- function(df){
  lm(corr_std_mean ~ mub_conc_uM, data = df)
}

m_stds_list <- stds_list_cols %>% 
  mutate(model = map(data, lm_mod_ftn))

b_fun <- function(mod){
  coefficients(mod)[[1]]
}

slope_fun <- function(mod){
  coefficients(mod)[[2]]
}

r_sq_fun <- function(mod){
  summary(mod)[["r.squared"]]
}

max_fluor_fun <- function(data){
  max(data$corr_std_mean)
}

stds_coeffs <- m_stds_list %>% 
  transmute(intcpt = map_dbl(model, b_fun), m_slope = map_dbl(model, slope_fun), r_squared = map_dbl(model, r_sq_fun), max_fluor = map_dbl(data, max_fluor_fun))

stds_coeffs

```

# Plot emission curves
```{r, emission-curves}
emission_only <- subset(stds_coeffs, id == "emission")

ext_coeff_tbl %>% 
  ggplot(aes(x = mub_conc_uM, y = corr_std_mean, color = plate)) + 
  geom_point() + 
  geom_abline(data = emission_only, aes(slope = m_slope, intercept = intcpt, color = plate)) +
  geom_text(data = emission_only, aes(x = 1.5, y = 8000,
                          label = paste("R^2=", round(r_squared, digits = 3))), inherit.aes = FALSE) + 
  geom_text(data = emission_only, aes(x = 1.0, y = 10000,
                                    label = paste(" y= ", round(m_slope, digits = 2),
                                      "x", " + ", round(intcpt, digits = 2))), inherit.aes = FALSE) + 
  facet_wrap(vars(plate)) + 
  
labs(title = "Emission standard curves")
```


# Plot quench curves
```{r, quench-curves}
quench_only <- subset(stds_coeffs, id == "quench")

quench_tbl %>% 
  ggplot(aes(x = mub_conc_uM, y = corr_std_mean, color = plate)) + 
  geom_point() + 
  geom_abline(data = quench_only, aes(slope = m_slope, intercept = intcpt, color = plate)) +
  geom_text(data = quench_only, aes(x = 1.5, y = 2000,
                          label = paste("R^2=", round(r_squared, digits = 3))), inherit.aes = FALSE) + 
  geom_text(data = quench_only, aes(x = 1.0, y = 2500,
                                    label = paste(" y= ", round(m_slope, digits = 2),
                                      "x", " + ", round(intcpt, digits = 2))), inherit.aes = FALSE) + 
  facet_wrap(vars(plate)) + 
  
labs(title = "Quench standard curves")
                                        

```


### Calculate extinction coefficient

The emission coefficient is the slope (m) from the emission standard curves you made above, divided by the assay volume 

Pay attention to units! 
**slope (m) units** from the standard curves = fluor/uM = fluor/ (umol/L) = fluor L / umol = fluor mL / nmol

**assay volume** is 250uL = 0.00025 L = 0.250 mL 

The protocol states: "Make sure this is calculated with the MUB concentrations in nmol/mL, which is equivalent to umol/L."" 

```{r, extintion-coefficient}
assay_vol_ml <- 0.250

# emission coefficient units are fluorescence / nmol
calc_emission <-  emission_only %>% 
  mutate(ext_coeff_fluor_per_nmol = m_slope/assay_vol_ml) %>% 
  select(plate, max_fluor, ext_coeff_fluor_per_nmol, intcpt)

calc_emission
```


### Calculate the quench coefficient 
```{r, quench-coefficient}
quench_coeff <- stds_coeffs %>% 
  pivot_wider(id_cols = plate, names_from = id, names_prefix = "slope_", values_from = m_slope) %>% 
  mutate(quench_coeff_no_unit = slope_quench/slope_emission)

quench_coeff

all_calcs <- cbind(quench_coeff, calc_emission) %>% 
  select(-id, -plate1)

all_calcs
```



### Add linear model data to sample dataset 

```{r}
#clean_data
```


```{r}

```

