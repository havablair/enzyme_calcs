---
title: "Hydrolytic Extracellular Enzyme Pre-test Calculations"
author: "Hava Blair"
date: "June 18, 2020"
output: html_document
---
## Enzyme Pre-test Calculations 

```{r, packages, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

## Load Packages 
library(tidyverse)
library(plater)
library(glue)
library(broom)
library(hms)

```

# Need to change mentions of "extinction" to "emission" ???  
# Think about setting warnings for when # of standards is <4, and for when assay fluor exceeds max std fluor.

## Read in plate templates

You need one completed template file (find template HERE XXXXXXX) for each plate, in CSV format. 

Name your file with the ID of your plate.  This will be added as its own column by plater so that you can identify which plate the data is coming from. 

Files used with this version of the script should contain all the metadata in the csv file itself, in 4 blocks:

  --"template" = standard, blank, and sample IDs.  Empty wells (no sample, standard, or check) may be coded as ".", "0" (zero), "NA", or left blank.
  
  --"Data" = raw fluorescence data from the plate reader
  
  --"bad_wells" = identifies any wells that have known problems (ex. pipetting errors).  May be coded as "bad", "Bad", "x", or "X".  Anything with NA (blank) will be kept as "good"
  
The files you want to process must all be in a single folder, and that folder must not contain any other files R will attempt to read in all files in the designated folder.

Now you are ready to read in your files. If you get an error, check whether you have any extra CSV files in the designated folder.

```{r files}
file.names <- dir("./plater-templates/")
file.paths<- paste0("./plater-templates/", file.names)
plates <- read_plates(file.paths)
colnames(plates) <- c("plate", "wells", "id", "fluor", "bad_wells", "ph_batch", "conc_uM")
head(plates)
unique(plates$plate) # To check that all plates read in correctly

#read in plate metadata
plate_metadata <- read.csv("./eea_plate_metadata.csv", stringsAsFactors = FALSE)

colnames(plate_metadata) <- c("plate", "sample_id", "ph_buffer", "moist_soil_mass_g", "soil_water_content", "vol_buffer_ml", "substrates", "time_soil_added", "time_naoh_added", "time_plate_read")

#parse the time columns so we can do math on them
plate_metadata <- plate_metadata %>% 
  mutate(time_soil_added = parse_hm(time_soil_added), 
         time_naoh_added = parse_hm(time_soil_added), 
         time_plate_read = parse_hm(time_plate_read))

# calculate incubation time and convert from seconds to hours
plate_metadata <- plate_metadata %>% 
  mutate(inc_time_hr = as.numeric(((time_plate_read - time_soil_added)/60/60)))

#calculate soil oven dry equivalent 

plate_metadata <- plate_metadata %>% 
  mutate(soil_ov_dry_eq_g = moist_soil_mass_g - (moist_soil_mass_g * soil_water_content))


```

## Remove empty wells and known bad wells


```{r, badwells}
#Remove empty wells
no_missing <- subset(plates, !is.na(id) & id != 0 & id != ".")

# Remove bad wells and keep good ones
no_bad <- subset(no_missing, is.na(bad_wells))

#Create a dataframe with the details about which wells were removed as "bad".  Can write this to CSV now, or wait until after later QC checks to compile a list of samples that need to be redone.
bad_list <- subset(no_missing, !is.na(bad_wells))

bad_list

#original PMN script from Miriam has the code below to remove bad wells. Based on the way I have been filling out my templates, I think it can be sipmlified to subsetting based on "is.na(bad_wells)"
# plates <- subset(plates, Bad_wells != "bad" & Bad_wells != "Bad" 
#                  & Bad_wells != "x" & Bad_wells != "X" | is.na(Bad_wells))

wells_removed <- nrow(plates) - nrow(no_bad)

glue("Removed {wells_removed} wells that were missing or bad")

clean_data <- no_bad

clean_nested <- clean_data %>% 
  group_by(plate) %>% 
  nest()

clean_data

clean_nested$data
```

```{r}
get_plate_blank <- function(data){
  buf <- data %>% 
    filter(id == "Buf")
    mean(buf$fluor)
}

test <- clean_nested %>% 
  mutate(plate_blank = map_dbl(data, get_plate_blank))

test

```


## MUB Standard calculations (for emission coeff calc)

```{r}
mub_std_fun <- function(data){
  data %>%
    select(wells, id, fluor, ph_batch, conc_uM) %>% 
    filter(str_detect(wells, "10")) %>% 
    group_by(id) %>% 
    summarise(mub_std_mean = mean(fluor), n = n()) #Add CV here?
}

mub_std_test <- test %>% 
  mutate(mub_std_values = map(data, mub_std_fun))

#Can always include an "unnest" option here for quick viewing of the plate numbers and standards


#Subtract the plate blank from the fluorescence values for each averaged concentration

corr_test <- mub_std_test %>% 
  unnest(mub_std_values) %>% 
  mutate(corr_std_mean = mub_std_mean - plate_blank, conc_uM = as.numeric(str_replace(id, "MUB", ""))) %>% 
  nest(std_data = c(id, mub_std_mean, n, corr_std_mean, conc_uM))

corr_test

```
### MUB + Soil Standards (Quench)

```{r}
#Obtain the plate blank + soil fluorescence value by averaging the values in column 11 (id = Buf+s) of each plate

get_mub_soil_blank <- function(data){
  buf_soil <- data %>% 
    filter(id == "Buf+s")
    mean(buf_soil$fluor)
}

calc_mub_soil_blnk <- corr_test %>% 
  mutate(mub_soil_blank = map_dbl(data, get_mub_soil_blank))

calc_mub_soil_blnk

#Average the MUB+soil wells (homogenate blanks) to get mean fluorescence for each concentration
quench_std_fun <- function(data){
  data %>%
    select(wells, id, fluor, ph_batch, conc_uM) %>% 
    filter(str_detect(wells, "09")) %>% 
    mutate(conc_uM = as.numeric(str_replace(conc_uM, "mub_", ""))) %>%
    group_by(conc_uM) %>% 
    summarise(mub_soil_std_mean = mean(fluor), n = n()) #Add CV here?
}

quench_test <- calc_mub_soil_blnk %>% 
  mutate(quench_std_values = map(data, quench_std_fun))

quench_test

#Subtract the blank values from the fluorescence values for each averaged MUB concentration and nest the results with the other quench data

quench_nested <- quench_test %>% 
  unnest(quench_std_values) %>% 
  mutate(corr_std_mean = mub_soil_std_mean - mub_soil_blank) %>% 
  nest(quench_data = c(conc_uM, mub_soil_std_mean, n, corr_std_mean))

quench_nested

```

##Linear model calculations 

```{r}
#function to run a linear model x = MUB concentration, y = mean fluorescence

lm_mod_ftn <- function(df){
  lm(corr_std_mean ~ conc_uM, data = df)
}

#can use this same function to calculate stats for both standard sets of standard curves 
lm_calcs <- quench_nested %>% 
  mutate(emis_lm = map(std_data, lm_mod_ftn), quench_lm = map(quench_data, lm_mod_ftn))

# functions to extract linear model details calculated above into a nicer format for putting in our graphs

b_fun <- function(mod){
  coefficients(mod)[[1]]
}

slope_fun <- function(mod){
  coefficients(mod)[[2]]
}

r_sq_fun <- function(mod){
  summary(mod)[["r.squared"]]
}

max_fluor_fun <- function(data){
  max(data$corr_std_mean)
}

#Extract linear model details from the buffer control linear model
emis_lm_details <- lm_calcs %>% 
  mutate(intcpt_emis = map_dbl(emis_lm, b_fun), slope_emis = map_dbl(emis_lm, slope_fun), r_squared_emis = map_dbl(emis_lm, r_sq_fun), max_fluor_emis = map_dbl(std_data, max_fluor_fun))

#nest the linear model details in a dataframe
nest_emis_stats <- emis_lm_details %>% 
  nest(lm_stats_emis = c(intcpt_emis, slope_emis, r_squared_emis, max_fluor_emis))

#Extract linear models details from the homogenate control linear model
quench_lm_details <- nest_emis_stats %>% 
  mutate(intcpt_quench = map_dbl(quench_lm, b_fun), slope_quench = map_dbl(quench_lm, slope_fun), r_squared_quench = map_dbl(quench_lm, r_sq_fun), max_fluor_quench = map_dbl(quench_data, max_fluor_fun))

#nest the linear model details in a dataframe
nest_quench_stats <- quench_lm_details %>% 
  nest(lm_stats_quench = c(intcpt_quench, slope_quench, r_squared_quench, max_fluor_quench))

nest_quench_stats
```


## Buffer control (MUB + Buffer) standard curves 

```{r}
#Function to make standard curve plots

plot_pts_fun <- function(std_data, lm_stats_emis, plate){
  g <- ggplot() + 
  geom_point(data = std_data, aes(x = conc_uM, y = corr_std_mean)) + 
    geom_abline(data = lm_stats_emis, aes(slope = slope_emis, intercept = intcpt_emis)) +
    geom_text(data = lm_stats_emis, aes(x = 1.0, y = 8000, label = paste("R^2=", round(r_squared_emis, digits = 3))), inherit.aes = FALSE) +
    geom_text(data = lm_stats_emis, aes(x = 1.0, y = 10000, label = paste(" y= ", round(slope_emis, digits = 2), "x", " + ", round(intcpt_emis, digits = 2))), inherit.aes = FALSE) + 
    labs(title = glue("{plate} buffer control standard curve"))
  return(g)
}


plot_test <- nest_quench_stats %>% 
  mutate(plot_buffer_control = pmap(list(std_data, lm_stats_emis, plate), plot_pts_fun))

plot_test$plot_buffer_control


```
## Homogenate control standard curves 

```{r}
plot_homog_fun <- function(quench_data, lm_stats_quench, plate){
  g <- ggplot() + 
  geom_point(data = quench_data, aes(x = conc_uM, y = corr_std_mean)) + 
    geom_abline(data = lm_stats_quench, aes(slope = slope_quench, intercept = intcpt_quench)) +
    geom_text(data = lm_stats_quench, aes(x = 1.0, y = (max_fluor_quench-300), label = paste("R^2=", round(r_squared_quench, digits = 3))), inherit.aes = FALSE) +
    geom_text(data = lm_stats_quench, aes(x = 1.0, y = (max_fluor_quench - 500), label = paste(" y= ", round(slope_quench, digits = 2), "x", " + ", round(intcpt_quench, digits = 2))), inherit.aes = FALSE) + 
    labs(title = glue("{plate} homogenate control standard curve"))
  return(g)
}


homog_plots <- plot_test %>% 
  mutate(plot_homog_control = pmap(list(quench_data, lm_stats_quench, plate), plot_homog_fun))

homog_plots$plot_homog_control

```

##Calculate emission coefficient

The *emission coefficient* is ((DEFINITION))
Formula for emission coefficient is:   (nice formatted formula)

The emission coefficient is the slope (m) from the emission standard curves you made above, divided by the assay volume 

Pay attention to units! 
**slope (m) units** from the standard curves = fluor/uM = fluor/ (umol/L) = fluor L / umol = fluor mL / nmol

**assay volume** is 250uL = 0.00025 L = 0.250 mL 

The protocol states: "Make sure this is calculated with the MUB concentrations in nmol/mL, which is equivalent to umol/L."" 

```{r, emission-coefficient}

# emission coefficient units are fluorescence / nmol


assay_vol_ml <- 0.250

emis_calc <- homog_plots %>% 
  mutate(emiss_coeff = map_dbl(lm_stats_emis, ~ as.numeric(.x[["slope_emis"]])/assay_vol_ml))

emis_calc


```

### Calculate the quench coefficient 

The quench coefficient is calculated as the slope of the quench standard curve divided by the slope of the buffer control (emission) standard curve.  

**Add more information about what the quench coefficient actually is...** 

```{r, quench-coefficient}


quench_coeff <- emis_calc %>% 
  mutate(quench_coeff = map2_dbl(lm_stats_emis, lm_stats_quench, ~ as.numeric(.x[["slope_emis"]])/as.numeric(.y[["slope_quench"]])))

quench_coeff
  
```



### Calculate means for assay and substrate control wells

```{r}
#extract the values for plate blank, homogenate blank (mub_soil_blank), emission coefficient, and quench coefficient
plate_data <- quench_coeff %>% 
  select(plate, plate_blank, mub_soil_blank, emiss_coeff, quench_coeff)

plate_data_df <- as.data.frame(plate_data)

#Calculate the mean fluorescence for the assay wells
mean_fluor_calcs <- clean_data %>% 
  filter(str_detect(id, "Assay")) %>% 
  group_by(plate, id, conc_uM) %>% 
  summarise(fluor_mean = mean(fluor), n = n(), sd = sd(fluor, na.rm = T), cv = sd(fluor, na.rm = T)/mean(fluor)*100)
  
mean_fluor_calcs <- mean_fluor_calcs %>% 
  mutate(conc_uM = as.numeric(str_replace(conc_uM, "sub_", "")))

#QC check - plot dist of each sample and enzyme to see what's normal?

#calculate the mean fluorescence for the substrate control wells
sub_controls <- clean_data %>% 
  filter(str_detect(id, "Blank")) %>% 
  group_by(plate, id, conc_uM) %>% 
  summarise(fluor_sub_control = mean(fluor), n = n(), sd = sd(fluor, na.rm = T), cv = sd(fluor, na.rm = T)/mean(fluor)*100) 

sub_controls <- sub_controls %>% 
  mutate(conc_uM = as.numeric(str_replace(conc_uM, "sub_", "")))

#select the columns for the mean substrate control fluorescence, plate number, and con_uM
sub_controls_select <- sub_controls %>% 
  select(fluor_sub_control, plate, conc_uM, id)


mean_fluor_calcs

assay_wells <- mean_fluor_calcs %>% 
  select(plate, id, conc_uM, fluor_mean)
  
substrate_controls <- sub_controls_select %>% 
  rename(fluor_mean = fluor_sub_control)

substrate_controls
assay_wells


merged <- rbind(substrate_controls, assay_wells)

fluor_wide <- merged %>% 
  pivot_wider(id_cols = c(plate, conc_uM), names_from = id, values_from = fluor_mean, names_prefix = "mean_fluor_", names_sep = "_")


#join the assay well fluorescence calculations with the plate daa (quench coff, emission coeff, blanks)
fluor_wide <- left_join(fluor_wide, plate_data_df, by = "plate")

fluor_wide

mean_fluor_calcs

```
##Calculate net fluorescence 

Net fluorescence = ((assay-homogenate control) / quench coefficient) - (substrate control-plate blank)

```{r, net-fluor-calc}

net_fluor_calcs <- fluor_wide %>% 
  mutate(net_fluor = ((`mean_fluor_B-Assay-ST2` - mub_soil_blank)/quench_coeff)-(`mean_fluor_B-Blank` - plate_blank))

```


##Calculate activity 

Activity(nmol/g^-1 h^-1) = [Net fluor x buffer vol (mL)] / [emis coeff x homogenate vol(mL) x time(h) x soil mass(g)]

Activity units are nmol / g^-1 hr^-1

```{r, activity-calc}

#buffer vol is the volume of buffer used to make the soil slurries. In the pre-test, this is 25mL.  In the regular protocol, it is 50mL
buffer_vol_ml <- 25

#vol of homogenate added to the assay wells
homogenate_vol_ml <- 0.200 

add_metadata <- left_join(net_fluor_calcs, plate_metadata, by = "plate")

add_metadata

activity_calcs <- add_metadata %>% 
  mutate(activity = (net_fluor * buffer_vol_ml) / (emiss_coeff * homogenate_vol_ml * inc_time_hr * soil_ov_dry_eq_g))

activity_calcs

activity_calcs %>% 
  ggplot() +
  geom_point(aes(x = conc_uM, y = activity, color = plate)) +
  facet_wrap(vars(plate))


```


### Old convoluted approach to calculating means for assay and substrate control wells

```{r}
# to get the assay fluorescence, need to average the assay wells for each enzyme at the different substrate concentrations  (group by id, conc_uM) and then substract the homogenate blank (mub_soil_blank)

assay_fluor_fun <- function(data, mub_soil_blank){
  data %>% 
  filter(str_detect(id, "Assay")) %>% 
  group_by(id, conc_uM) %>% 
  summarise(fluor_assay_mean = mean(fluor)-mub_soil_blank, n = n(), sd = sd(fluor, na.rm = T), cv = sd(fluor, na.rm = T)/mean(fluor)*100)
}

assay_fluor_calc <- quench_coeff %>% 
  mutate(assay_fluor_data = map2(data, mub_soil_blank, assay_fluor_fun))

# substrate controls need to be averaged across the different concentrations, and subtract the plate blank 

subs_control_fun <- function(data, plate_blank){
  data %>%
    filter(str_detect(id, "Blank")) %>% 
    group_by(id, conc_uM) %>% 
    summarise(fluor_sub_control_mean = mean(fluor) - plate_blank, n = n(), sd = sd(fluor, na.rm = T), cv = sd(fluor, na.rm = T)/mean(fluor)*100)
}

sub_control_calc <- assay_fluor_calc %>% 
  mutate(sub_control_data = map2(data, plate_blank, subs_control_fun))

join_df <- function(assay_fluor_data, sub_control_data, quench_coeff, emiss_coeff){
  
}
```
##Calculate net fluorescence 

Net fluorescence = ((assay-homogenate control) / quench coefficient) - (substrate control-plate blank)

(assay fluor - homogenate control fluor) = fluor_assay_mean *(calculated above*)

(substrate control - plate blank) = fluor_sub_control_mean *(calculated above)*

```{r}
#Note that the fluorescence of the homogenate control was subtracted from the assay fluorescence in the chunk above so our formula becomes (fluor_assay_mean / quench coefficient) - substrate control



test_net_fluor <- sub_control_calc %>% 
  mutate(net_fluor = pmap(list(assay_fluor_data, quench_coeff, sub_control_data), ~(..1[["fluor_assay_mean"]]/..2) - ..3[["fluor_sub_control_mean"]]))

test_net_fluor$net_fluor

net_fluor_fun <- function(assay_fluor_data, quench_coeff, sub_control_data){ 
  
  }


```

